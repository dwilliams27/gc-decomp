"""Gather context for a function: headers, types, and nearby matched functions."""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path

from decomp_agent.config import Config
from decomp_agent.melee.report import Report
from decomp_agent.tools.run import run_in_repo
from decomp_agent.tools.source import find_functions, read_source_file


@dataclass
class FunctionContext:
    """Context gathered for a function to help with decompilation."""

    function_name: str
    source_file: str  # relative path e.g. "melee/lb/lbcommand.c"

    # The preprocessed context (all headers inlined)
    preprocessed_ctx: str | None = None

    # Source of the file containing this function
    file_source: str | None = None

    # Nearby matched functions from the same file (for style reference)
    nearby_functions: list[str] = field(default_factory=list)

    # Header content directly included by this file
    includes: list[str] = field(default_factory=list)

    def format_for_llm(self, max_ctx_chars: int = 50_000) -> str:
        """Format context into a string suitable for LLM input."""
        parts: list[str] = []

        parts.append(f"=== Context for {self.function_name} ===")
        parts.append(f"Source file: src/{self.source_file}")
        parts.append("")

        if self.preprocessed_ctx:
            ctx = self.preprocessed_ctx
            if len(ctx) > max_ctx_chars:
                ctx = ctx[:max_ctx_chars] + "\n... (truncated)"
            parts.append("=== Preprocessed headers and types ===")
            parts.append(ctx)
            parts.append("")

        if self.nearby_functions:
            parts.append("=== Nearby matched functions (for reference) ===")
            for func_src in self.nearby_functions:
                parts.append(func_src)
                parts.append("")

        return "\n".join(parts)


def _get_ctx_file(source_file: str, config: Config) -> Path:
    """Get the path to the .ctx file for a source file.

    The .ctx file is generated by decompctx.py during the build and
    contains all headers inlined into a single file.
    """
    stem = source_file.rsplit(".", 1)[0]
    return (
        config.melee.repo_path
        / config.melee.build_dir
        / config.melee.version
        / "src"
        / f"{stem}.ctx"
    )


def _generate_ctx(source_file: str, config: Config) -> str:
    """Generate context by running decompctx.py or reading cached .ctx file.

    Raises RuntimeError if context cannot be generated.
    """
    ctx_path = _get_ctx_file(source_file, config)

    # Try reading the cached .ctx file first
    if ctx_path.exists():
        return ctx_path.read_text(encoding="utf-8", errors="replace")

    # Try generating it via ninja
    ctx_target = str(ctx_path.relative_to(config.melee.repo_path))
    result = run_in_repo(["ninja", ctx_target], config=config, timeout=60)
    if result.returncode != 0:
        raise RuntimeError(
            f"Failed to generate .ctx for {source_file}: "
            f"{result.stderr or result.stdout}"
        )
    if not ctx_path.exists():
        raise RuntimeError(
            f"ninja succeeded but .ctx file not found at {ctx_path}"
        )
    return ctx_path.read_text(encoding="utf-8", errors="replace")


def _get_nearby_matched_functions(
    source_file: str,
    target_function: str,
    config: Config,
    report: Report | None = None,
    max_functions: int = 3,
) -> list[str]:
    """Find matched functions in the same source file as reference examples.

    Returns the source code of up to max_functions matched functions
    from the same file, preferring functions near the target.
    """
    src_path = config.melee.repo_path / "src" / source_file
    if not src_path.exists():
        raise FileNotFoundError(
            f"Source file not found: {src_path}"
        )

    source = read_source_file(src_path)
    spans = find_functions(source)
    lines = source.splitlines()

    if not spans:
        return []

    # Find the target function's position
    target_idx = None
    for idx, span in enumerate(spans):
        if span.name == target_function:
            target_idx = idx
            break

    # If we have a report, filter to matched functions
    matched_names: set[str] | None = None
    if report:
        stem = source_file.rsplit(".", 1)[0]
        unit = report.get_unit(stem) or report.get_unit(f"main/{stem}")
        if unit:
            matched_names = {
                f.name for f in unit.functions if f.fuzzy_match_percent == 100.0
            }

    # Collect candidate functions (excluding the target)
    candidates: list[tuple[int, str]] = []
    for idx, span in enumerate(spans):
        if span.name == target_function:
            continue
        # Skip if we know it's not matched
        if matched_names is not None and span.name not in matched_names:
            continue
        func_src = "\n".join(lines[span.start_line : span.end_line + 1])
        # Sort by proximity to target
        distance = abs(idx - target_idx) if target_idx is not None else idx
        candidates.append((distance, func_src))

    candidates.sort(key=lambda x: x[0])
    return [src for _, src in candidates[:max_functions]]


def get_function_context(
    function_name: str,
    source_file: str,
    config: Config,
    report: Report | None = None,
    include_ctx: bool = True,
    include_nearby: bool = True,
    max_nearby: int = 3,
) -> FunctionContext:
    """Gather complete context for decompiling a function.

    Args:
        function_name: Name of the target function
        source_file: Object name from configure.py e.g. "melee/lb/lbcommand.c"
        config: Project configuration
        report: Optional pre-parsed report for filtering matched functions
        include_ctx: Whether to include preprocessed headers
        include_nearby: Whether to include nearby matched functions
        max_nearby: Max number of nearby functions to include
    """
    ctx = FunctionContext(
        function_name=function_name,
        source_file=source_file,
    )

    # Read the source file
    src_path = config.melee.repo_path / "src" / source_file
    if not src_path.exists():
        raise FileNotFoundError(f"Source file not found: {src_path}")
    ctx.file_source = read_source_file(src_path)

    # Get preprocessed context (all headers inlined)
    if include_ctx:
        ctx.preprocessed_ctx = _generate_ctx(source_file, config)

    # Get nearby matched functions
    if include_nearby:
        ctx.nearby_functions = _get_nearby_matched_functions(
            source_file, function_name, config, report, max_nearby
        )

    # Collect include file names from the source
    if ctx.file_source:
        for line in ctx.file_source.splitlines():
            stripped = line.strip()
            if stripped.startswith("#include"):
                ctx.includes.append(stripped)

    return ctx
